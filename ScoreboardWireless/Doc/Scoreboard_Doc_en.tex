\documentclass[11pt,english]{article}
\usepackage{geometry}
\usepackage{color}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}

\makeatletter

%% User specified LaTeX commands.
\usepackage{color}
\usepackage[font=footnotesize,labelfont=bf]{caption}
\usepackage{listings}
\usepackage{pxfonts}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage{subfig}
\usepackage{multirow}
% To place footnotes at the bottom of the page
\usepackage[bottom]{footmisc}

% hyperref setup
\hypersetup{
  colorlinks=true,        % false: boxed links; true: colored links
  linkcolor=red,          % color of internal links (change box color with linkbordercolor)
  citecolor=green,        % color of links to bibliography
  filecolor=magenta,      % color of file links
  urlcolor=cyan           % color of external links
}

\geometry{verbose,a4paper,tmargin=3cm,bmargin=3cm,lmargin=2.5cm,rmargin=2.5cm,headheight=3cm,headsep=3cm}

\DeclareGraphicsExtensions{.png,.pdf,.jpg}

\setlength{\parskip}{\smallskipamount}
\setlength{\parindent}{0pt}
\renewcommand{\rmdefault}{cmr}
\renewcommand{\familydefault}{\rmdefault}

% Scientific notation
\providecommand{\e}[1]{\ensuremath{\times 10^{#1}}}

% Monospaced font with bold typeface
\DeclareFontShape{OT1}{cmtt}{bx}{n}{<5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

% Colors for listings
\definecolor{colKey}{rgb}{0,0,1}
\definecolor{colId}{rgb}{0,0,0}
\definecolor{colComments}{rgb}{0.247,0.498,0.254}
\definecolor{colEmph}{rgb}{0.498,0.286,0}
\definecolor{colString}{rgb}{0.05,0,0.8}
\definecolor{grigino}{rgb}{0.93,0.93,0.93}
\definecolor{gray}{rgb}{0.7,0.7,0.7}


% Listings captions gray box
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{%
  \parbox{\textwidth}{\colorbox{gray}{\parbox{0.986\textwidth}{#1#2#3}}\vskip-4pt}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

% Listing options set
\lstset{
  basicstyle=\scriptsize\ttfamily,
  float,
  showstringspaces=false,
  lineskip=-1pt,
  extendedchars=true,
  numbers=left,
  stepnumber=1,
  numberstyle=\tiny,
  numbersep=5pt,
  xleftmargin=2em,
  xrightmargin=2em,
  breaklines,
  language=C++,
  identifierstyle=\color{colId}, 
  keywordstyle=\color{colKey}, 
  stringstyle=\color{colString}, 
  commentstyle=\color{colComments},
  frame=lrb,
  rulecolor=\color{gray},
  framexleftmargin=15pt,
  framexrightmargin=15pt,
  morekeywords={uint16_t,uint32_t,byte,boolean}
}

% Listings custom keywords
\lstset{emph={%  
    _nDisplay, _displays, _value, _digits, _index, _name, _bitOrder, _groups%
    },emphstyle={\color{colEmph}}%
}%

\usepackage{babel}
\makeatother

%  Style for code names into text 
\newcommand{\code}[1]{\texttt{#1}}

% Overline in text mode
\newcommand{\textoverline}[1]{$\overline{\mbox{#1}}$}


\begin{document}

\begin{titlepage}
\begin{center} 

~\\[1.5cm] 
\textbf{{\Huge SCOREBOARD PROJECT}
~\\[0.7cm]}
\LARGE{Electronic board \\
with 7-segments displays\\
and Arduino
~\\[0.8cm]
version 0.8}
\large{~\\[0.8cm]
Revamped with wireless controller!!}
~\\[1.6cm]

\includegraphics[scale=0.30]{img/Scoreboard}

~\\[1.5cm]
\normalsize Gionata Boccalini
~\\[0.5cm]
\normalsize \today

\end{center} 
\vspace*{1cm}
\end{titlepage}


\newpage{}

\tableofcontents{}


\listoffigures

\lstlistoflistings

\newpage{}



\section{Introduction}

This document describes the design and realization of an electronic scoreboard, 
that I was asked to make for my local basketball team. I had some experience with 
7-segments displays (from school) and with microelectronics so I decided to make 
my own scoreboard, using basic electronic blocks and Arduino as CPU. I had to seek 
for the right components on the Internet for months, and to put everything together 
in my garage, with the help of my father and some of my friends. Some parts were 
already made and some I had to build from scratch using tools that I would have never 
thought I used.The whole process took months but the final result was really 
impressive for me, given the knowledge and possibilities I had.

The rest of the document is organized in two main section, one describing the hardware 
part and the other speaking about the software. I will try to describe the most 
important aspects, using pictures, and give the main idea of simplicity and robustness 
that I tried to achieve.

I have to cite the source \footnote{\url{http://kiantech.me/entries/2011/6/21/live-nba-scoreboard.html}} 
where I found the inspiration to build this scoreboard, and from which I took some 
design hints. The site is run by Mr. Kianoosh Salami, who was really helping me in the 
process of finding the components and building the board.

I have also to thank many of my friends for the help, the knowledge they gave me and the
inspiration derived from the discovery of the \textquotedblleft Do it yourself\textquotedblright 
electronic field, represented by the Italian Arduino platform.   

Thank you!!

\section{Hardware}

The scoreboard has been completely realized by hand, starting from scratch, using wood 
for the chassis to create a box with an open side where I could put the electronic 
components. We made some holes for the 7-segments displays and the external connections.
Some pictures will explain better than words:

The chassis was robust enough to hold the displays, Arduino, and the wiring.
The list of components, with pictures, is shown in section \ref{subsec:components}.


\subsection{Components}\label{subsec:components}

The main components are:

\begin{itemize}
 \item 7-segments displays: I found those ones in a Chinese electronic company site, 
 Sure Electronics \footnote{\url{http://www.sureelectronics.net/goods.php?id=721}}, 
 selling worldwide, and I was very lucky because those displays already integrates the 
 electronic logic to  control the data flow from the CPU to the integrated shift registers. 
 Thus I saved the  effort to make my own circuit to drive the displays!!
 
  %
  \begin{figure}[H]
  \centering\includegraphics[scale=0.25]{img/7-inch-dis}

  \caption{A 7 inch 7-segments displays \label{fig:7-inch-dis}}

  \end{figure}
  
 \item Arduino: this is an Italian prototype platform really easy to use, with open source 
 software and standard hardware which helps non professional electronic designer and engineer 
 to develop their own application. I used this CPU to control the whole panel, the displays 
 and the digital inputs.
 
   %
  \begin{figure}[H]
  \centering\includegraphics[scale=0.25]{img/Arduino}

  \caption{Arduino UNO platform\label{fig:arduino}}

  \end{figure}
 
 \item homemade connection boards: I used those ones to connect the CPU to the rest of the 
 circuit, like the control panel and the 7-segments displays. Later in this document or in the 
 download section of the project site \footnote{\url{http://code.google.com/p/display-group/}}  
 you can find the Eagle schematic and board files.
 
  %
  \begin{figure}[H]
  \centering\includegraphics[scale=0.25]{img/Board}

  \caption{Homemade connection board without components \label{fig:board}}

  \end{figure}
 
 \item wood and DIY materials.
 
\end{itemize}


\subsection{ScoreBoard electrical connections}

The 7-segments are powered by a 12 V PSU, I decided to connect the power in parallel to all the boards:
the data link can carry 1 A current, but that is not enough to power 7 displays boards on the same bus.
Considering that Arduino is also powered by the same PSU, and the input are also, I used a 6.75 A, 12 V
PSU, just to be sure the current would be enough for everything.
The figure \ref{fig:board-back} shows the back of the scoreboard with all the components:

%
\begin{figure}[htb]
\centering\includegraphics[scale=0.42]{img/Board-back}

\caption{Back side of the board, with Arduino and electrical connections \label{fig:board-back}}

\end{figure}

You can also see the external connections, in the bottom right corner:

\begin{itemize}
 \item Power cord: to power the whole board;
 \item USB: to program the Arduino when the board will be installed on the wall;
 \item Ethernet: to connect the control panel.
\end{itemize}

The data link between the CPU and the displays is made with a 10 pole IDC cable, with three data pins, 
as shown in figure \ref{fig:j1}. 

%
\begin{figure}[htb]
\centering\includegraphics[scale=0.45]{img/J1-con}

\caption{Power and data connection on the 7-segments board \label{fig:j1}}

\end{figure}

The pins are described as follows
\begin{itemize}
 \item \textbf{DIMM/OE}: to control the brightness of the LEDs and the output enable of the shift registers;
 \item \textbf{DATA}: to shift in data bits;
 \item \textbf{CLK}: to clock the data bits on the bus.
\end{itemize}

To have more information on the displays and the electronic behind look on the project site, download 
section, for the displays datasheets.

I used an electronic board to make the data connection persistent, as shown in figure \ref{fig:board}, 
with standard connectors soldered on it: figure \ref{fig:board-schem} shows the board PCB circuit made with 
Eagle CAD software.

%
\begin{figure}[htb]
\centering\includegraphics[scale=0.30]{img/Board-schem}

\caption{Connection board schematic \label{fig:board-schem}}

\end{figure}

The OE, DATA, CLOCK pins come from Arduino, and are routed to the IDC connector, together with the 12 V line and 
ground. The IDC cable goes to the first 7-segments display (top right corner in figure \ref{fig:board-back})
the IDC output connector goes to the second display on its left, and so on. Using a digital shift out technique 
on Arduino it is possible to update all the displays at a time. The DisplayGroup library has been used for this 
purpose.

The two displays at the bottom of figure \ref{fig:board-back} are the last two of the queue: they are 4 inch tall 
and use the same hardware interface of the 7 inch displays, but the segments bit code is different!
The DisplayGroup library can handle this representation difference in transparent way to the user.


\subsection{Control panel}\label{subsec:contro-panel}

The small control panel shown in figure \ref{fig:panel} has been built to give the user the possibility 
to remotely control the scoreboard during the game. The buttons are described in picture \ref{fig:panel-schem}.

%
\begin{figure}[htb]
\centering\includegraphics[scale=0.35]{img/Panel}

\caption{Control panel \label{fig:panel}}

\end{figure}

There is a \textquotedblleft shift\textquotedblright like button to enable additional function like the set 
of the timer and the reset of score.

%
\begin{figure}[H]
\centering\includegraphics[scale=0.35]{img/Panel-schem}

\caption{Control panel front view \label{fig:panel-schem}}

\end{figure}

The panel is powered by the Arduino 5 V output through the Ethernet cable; this is the only cable needed to make 
the panel work: it brings the power and the data link, using only five cable out of the eight present in the 
Ethernet cable.
Those cables are mapped to the Arduino analog input: this means that, since the buttons are digital switch, I 
had to build a board to extend the Arduino input capability: using only 3 analog input Arduino can receive 
12 digital inputs, with the correct resistors and the help of the software 
\footnote{\url{http://www.instructables.com/id/How-to-access-5-buttons-through-1-Arduino-input/?ALLSTEPS}}. 
The board schematic is shown in figure \ref{fig:panel-board}:

%
\begin{figure}[htb]
\centering\includegraphics[scale=0.25]{img/Panel-board}

\caption{Control panel connection board \label{fig:panel-board}}

\end{figure}

The board is essentially a voltage divider with three voltage sample, one for each analog input: every button 
has its particular size of the divider resistor, so when the user pushes a button the corresponding voltage 
value goes to the correct analog input. Those values are hard coded into the control program on the CPU; 
the library for the input control scans the analogs input and calls the correct function when needed. This
library will be described in section \ref{subsec:dep}.

I used a straight Ethernet cable but, due to the necessary joints, I had to map the cable differently between the 
two communication sides: as you can see from picture \ref{fig:panel-cable} the orange-white e green-white 
cables are swapped:

%
\begin{figure}[htb]
\centering\includegraphics[scale=0.40]{img/Panel-cable}

\caption{Control panel connection board \label{fig:panel-cable}}

\end{figure}

By using this cabled solution I was able to control the scoreboard with a quite long cable (12 meters), 
while keeping the realization cost low. The other solution would be a wireless communication, but that 
would also be more expensive.


\subsection{Wireless Extension}\label{subsec:hd-wireless}

The wireless communication was not needed by the time I realized the first version of the scoreboard, but 
then, after 2 years of good use of the system, my basketball team was able to switch championship.. to an 
upper level! So new championship means new rules!
The space between the field border and the wall on the scoreboard side was not enough for the new, more strict,
rules. We needed to move the service desk to the other side of the field. The cable between the control panel 
and the scoreboard would have been way too long and difficult to place, so this is when the wireless saga began!    

The research for the right components took me months, as I was looking for all these features;
\begin{itemize}
 \item fast enough and reliable communication, even with many disturbances (cellphones, etc..);
 \item wireless range cover (20-30 meters);
 \item small components to fit in the control panel I had already, without changing anything inside;
 \item long battery life;
 \item easy realization, homemade as always!
\end{itemize}

I found the XBee RF Modules \footnote{\url{http://www.digi.com/products/wireless-wired-embedded-solutions/zigbee-rf-modules/point-multipoint-rfmodules/xbee-series1-module}} to meet the unique needs of low-cost, low-power wireless sensors, 
since they require minimal power and provide reliable delivery of data between devices. For the purpose of this 
application I used the Xbee 802.15.4 Series 1 module, which are more than enough for me, and not too much expensive:

\begin{itemize}  
 \item Indoor/Urban range up to 100 feet (30 m) 
 \item TX Peak Current: 45 mA (@3.3 V)
 \item RX Current: 50 mA (@3.3 V)
 \item Transmit Power: 1 mW (0 dBm)
 \item Receiver Sensitivity: -92 dBm  
\end{itemize}

These Xbee module are also equipped with an on board analog to digital converter, so that I could connect my buttons 
board directly to the Xbee: all the hard work of collecting the samples and sending them over the air is done by the 
module! The Xbee are also really easy to configure, and they have a lot of options.

I decide to use a power switching IC to optimize the battery power usage, and I wanted to use two standard AA sized
Alkaline battery. The power consumption is really low during data transmission but I wanted to keep everything even 
lower and use some of the intelligent Xbee features like hibernation (\emph{sleep mode}). These two requirements gave 
me the possibility to learn a lot on power management in electronic devices, and even on using and programming small
MCU not related to Arduino. 

\subsubsection{Transmitter board}\label{subsec:hd-wireless_trans}

The picture \ref{fig:board-trans-sch} shows the schematic circuit for the transmitter board I designed. It is base on some main 
component and a some auxiliary components that are needed to make everything work smoothly.

%
\begin{figure}[htb]
\centering\includegraphics[scale=0.65]{img/Transmitter}

\caption{Transmitter board schematic \label{fig:board-trans-sch}}

\end{figure}

The real board is manufactured by the Seeed Studio Fusion PCB service \footnote{\url{https://www.seeedstudio.com/service/index.php?r=pcb}}, (yes... this one is too cluttered to be made by hand),  
really fast and easy to use service from China. The board is in picture \ref{fig:board-trans}, the quality is good and 
the price is well worth the product you'll get.
The schematic and board file made with Eagle are available in the Google Code site of this project, in the download page. 

\begin{figure}[htb]%
    \centering
    \subfloat[]{{\includegraphics[width=4cm]{img/Trans_board} }}%
    \qquad
    \subfloat[]{{\includegraphics[width=4cm]{img/Trans_board_comp} }}%
    \caption{Transmitter board from Seeed Studio (a), and board with components (b)}%
    \label{fig:board-trans}%
\end{figure}

The power converter is a Maxim MAX757 switching power regulator\footnote{\url{http://www.maximintegrated.com/en/products/power/switching-regulators/MAX757.html}}, 
connected as shown in the datasheet, with a LED connected on the LBO output, to signal the end of battery life with some 
time in advance. The threshold for the battery voltage to signal the battery as empty is set with R3 and R4, all the details 
are given in the datasheet. 

Figure \ref{fig:board-battery} shows the circuit working region with and without the step-up regulator: some digital component like 
Xbee can work with not less than 2.8V as Vcc, this makes 1.4V per battery (with two batteries connected in series).
In figure \ref{fig:board-battery}:A the minimum level of 1.4V is reached at $t_1$, which is about 2.5 hours of running time, 
at constant 100mA discharge current, 21 Â°C. With a power regulator like the MAX757, that can work down to 0.7V of input 
supply voltage, the working region is extended like in \ref{fig:board-battery}:B. The level 0.8V is reached at $t_1$, almost 
at 28 running hours, and the regulator is still working in good conditions, with a constant output voltage of 3.3V to supply 
the Xbee and the rest of the circuit for much more time. Figure \ref{fig:board-battery} is just for demonstration purpose.
    
%
\begin{figure}[htb]
\centering\includegraphics[scale=0.8]{img/Battery}

\caption{Typical alkaline battery discharge curve, with working region for the circuit: (a) without power regulator, (b) with 
power regulator\label{fig:board-battery}}

\end{figure}

The typical auxiliary circuit for the regulator is better explained in the datasheet, for the purpose of this application 
I have just added a transistor controlled by the LBO output, to switch on the LED without current drain from the IC itself.
The LBO output is only capable of 2mA, not enough to turn on the LED2 to be visible. 

The micro-controller in figure \ref{fig:board-trans} is a Atmel AVR ATTiny 85V\footnote{\url{http://www.atmel.com/devices/attiny85.aspx}}, 
ultra low voltage MCU. It is used to wake up the Xbee module only when necessary, so that the Xbee can sleep most of the time.
When the Xbee is Pin Hibernate mode uses only 10uA, much less than transmitting current 45mA. In this mode the Xbee can be 
waken up only by setting low the line on input 9 \textoverline{DRT}/SLEEP\_RQ, and this is the job of the micro-controller.
The MCU watch the 3 analog inputs to detect a pressed button, and wakes up the Xbee. The Xbee will sample the data from 
the same analog channels and send it over the RF link. The code running on the MCU is described in listing \ref{lis-attiny}.

The LED1 is used to signal that the Xbee is awake.

The JP2 connector is directly connected to the board in figure \ref{fig:panel-board}, providing power (3.3V) and retrieving 
the three analog values from the buttons. These lines will be sampled by the Xbee and transmitted to the other Xbee in the 
scoreboard in a \emph{autonomous way}, once the Xbee are configured correctly.

The capacitors C1, C2, C4 and C5 are filters on the power supply; they are needed to provide a constant, smooth voltage 
to the integrated components. The regulator itself works in a region were it's switching frequency is about 100kHz (datasheet)
but the Xbee requires at least 500kHz as a good recommendation on the power supply. I couldn't find another regulator with 
the same features and higher switching frequency, so I added some big electrolytic capacitors to minimize the voltage ripple.
The analog values are almost constant and all the ICs are working correctly! 


\subsubsection{Receiver board}\label{subsec:hd-wireless_rec}

The picture \ref{fig:board-rec-sch} shows the schematic circuit for the receiver board, which is mounted on the back of 
the scoreboard, near Arduino and the displays. 
The board is home made with a really nice technique used to create PCBs, called Press-n-Peel\footnote{\url{http://www.techniks.com/how_to.htm}}, 
which is easy and you can get beautiful PCB in short time. 
%
\begin{figure}[htb]
\centering\includegraphics[scale=1.0]{img/Receiver}

\caption{Receiver board schematic \label{fig:board-rec-sch}}

\end{figure}

The board is made of a low dropout linear voltage regulator, this time with input up to 16V, to use the power supply voltage
on the scoreboard which is 12V. The output is fixed 3.3V to supply the Xbee module, with filtering capacitor as shown in 
the datasheet. The Xbee DOUT line is directly connected to the serial input pin of the Arduino, while the DIN line from 
Arduino [0, 5V] is buffered with a voltage divider, to take the signal in the range [0, 3.3V] to be compatible with the Xbee.
LED1 is used to show the strength of the received signal (RSSI), and LED2 is used to indicate that this Xbee is associated 
with another node in the network.

The complete board is shown in picture \ref{fig:board-trans-comp}, the Xbee used here has the RPSMA connector, with a 
long WIFI antenna, which is long enough to take the receiving part outside of the scoreboard metal cage. 
This Xbee module with this type of antenna is a little bit more expensive than the standard ones, but it was the most easy 
way I found to avoid problems like disturbances or signal degradation at the receiving site.

\begin{figure}[H]%
    \centering
    \subfloat[]{{\includegraphics[width=5.5cm]{img/Rec_board} }}%
    \qquad
    \subfloat[]{{\includegraphics[width=7cm]{img/Rec_board_comp} }}%
    \caption{Receiver board, bottom layer (a), and board with components (b)}%
    \label{fig:board-trans-comp}%
\end{figure}

\subsubsection{Xbee configuration - transmitter}\label{subsec:hd-xbee_config_trans}

The transmitter Xbee is able to sample the ADC data from the input lines, build the serial data frame according to the 
frame type RX Packet, 16-bit Address IO (API Identifier Value: 0x83), and send the frame to the UART. If the 
\textoverline{DRT}/SLEEP\_RQ line is high the Xbee will switch to the configured sleep mode once has finished the packet 
transmission. To achieve this kind of behavior the configuration is set as in table \ref{tab:trans-param}, where only non-default 
parameters are shown.


\begin{table}[h]
\begin{center}
\begin{tabular}{ |l|l|l|l| }
\hline
\multicolumn{4}{ |c| }{\large{\textbf{Transmitter Xbee configuration}}} \\
\hline
\textbf{Section} & \textbf{Parameter} & \textbf{Value} & \textbf{Description} \\ \hline
\multirow{5}{*}{Network \& Security} & CH & 10 & Channel \\
 & ID & 3340 & PAN ID \\
 & DH & 13A200 & Destination Xbee address high part \\
 & DL & 40A191C7 & Destination Xbee address low part \\ 
 & MY & 2 & 16Bit source address\\ \hline
\multirow{3}{*}{Sleep modes} & SM & 1 & Sleep mode \\
 & ST & 1 & Time before sleep \\
 & DP & 14 & Disassociated cyclic sleep period  \\ \hline
\multirow{1}{*}{Serial interfacing} & BD & 3 & Interface data rate \\ \hline
\multirow{6}{*}{I/O Settings} & D5 & 0 & DIO5 configuration \\ 
 & D3 & 2 & DIO3 configuration \\
 & D2 & 2 & DIO2 configuration \\
 & D1 & 2 & DIO1 configuration \\
 & IT & 2 & Sample before transmission \\
 & IR & 28 & Sample rate \\ \hline
\end{tabular}
\caption{Transmitter Xbee configuration parameters}%
\label{tab:trans-param}%
\end{center}
\end{table}

The sleep mode is Pin Hibernate, which provides the best energy save, and the time before sleep is as short as possible.
DIO1-2-3 are used as analog input, sample are taken every 64ms (28 Hex) when Xbee is awake, and a package is sent every 
2 samples collected, so every 128ms. This is fast enough to provide sufficient response time when a button is pressed: the 
time needed for two consecutive buttons to get to Arduino is usually less the 300ms, enough to stop and start the timer with 
the precision I wanted for this application.

\subsubsection{Xbee configuration - receiver}\label{subsec:hd-xbee_config_rec}

The receiver Xbee is configured as the network coordinator (even if this is not a meshed, multinode network...), it simply 
listens on the radio interface for packages from the transmitting node. When a frame is received the Xbee sends it 
to the Arduino via a simple serial interface. The configuration is shown in table \ref{tab:rec-param}.

\begin{table}[h]
\begin{center}
\begin{tabular}{ |l|l|l|l| }
\hline
\multicolumn{4}{ |c| }{\large{\textbf{Receiver Xbee configuration}}} \\
\hline
\textbf{Section} & \textbf{Parameter} & \textbf{Value} & \textbf{Description} \\ \hline
\multirow{5}{*}{Network \& Security} & CH & 10 & Channel \\
 & ID & 3340 & PAN ID \\
 & DH & 0 & Destination Xbee address high part \\
 & DL & 0 & Destination Xbee address low part \\ 
 & MY & 1 & 16Bit source address\\ 
 & CE & 1 & Coordinator enable \\ \hline
\multirow{1}{*}{Sleep modes} & DP & 14 & Diassociated cyclic sleep period  \\ \hline
\multirow{1}{*}{Serial interfacing} & BD & 3 & Interface data rate \\ \hline
\end{tabular}
\caption{Receiver Xbee configuration parameters}%
\label{tab:rec-param}%
\end{center}
\end{table}

The serial interface data rate to Arduino is limited to 19200 baud, because of some problem with clock synchronization 
between the Xbee and Arduino. This speed was enough for my needs, so I decided to keep the slower (and more reliable) speed.

Some more information regarding this timing problems can be found at the Digi forum\footnote{\url{http://www.digi.com/support/forum/4787/using-the-xbee-at-115-200-baud-updated-16-march-2010}}, 
and in other unofficial resources on the Internet. 


\subsubsection{ATtiny configuration}\label{subsec:hd-attiny_config}

The ATtiny85 MCU on the transmitter board is configured to minimize the power consumption, and is used to monitor the analog 
signal more often than the Xbee, with much less current drained.
The configuration is done via software, as the following code shows:
%
\begin{lstlisting}[label=lis:ATtiny-config,caption=ATtiny85V configuration]
void setup() {
  pinMode(WAKE_OUTPUT, OUTPUT);
  digitalWrite(WAKE_OUTPUT, HIGH);

  // Setup watchdog timeout
  setup_watchdog(0);

  // Set the internal registers to reduce power consumes
  PRR &= ~(1<<PRTIM1);		// Shut down the timer1
  ACSR = (1<<ACD);		// Shut down the analog comparator
  MCUCR |= (1<<BODS);		// BOD disabled

} // End of setup
\end{lstlisting}

Timer1, analog comparator and BOD protection are tunerd off by defautl. When the MCU wakes up, the ADC convert is turned on, 
and then back off before the MCU sleeps again.

The sleep mode is \code{SLEEP\_MODE\_PWR\_DOWN}: in this mode the oscillator is stopped, while the external interrupts, the USI 
start condition detection and the watchdog continue operating.
The watchdog interrupt is used to wake the MCU every a predefined amount of time, in this case 16ms, through the function 
\code{setup\_watchdog(0)}, which sets the watchdog timeout in the MCU registers.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Hardware END - software BEGIN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\pagebreak

\section{Software}

The control software is made of three library and a main logic, written in C++, with the use of Arduino 
API and C++ STL library (Arduino version). The README and INSTALL document in the root folder of the 
project explain where to find those libraries, and then you can understand how to compile them. The 
rest of the compilation process is done by Eclipse or by the makefile. Also the flashing of the program 
on the Arduino program memory is automatically done, provided that all the needed tools are installed.

\subsection{Dependencies}\label{subsec:dep}

The most important dependence is the DisplayGroup library, which has already been described in the 
documentation at the project folder, on the Google code svn server (INSTALL file). This library is needed 
to support in an efficient way many 7-segments connected to a serial bus, each with a shift register, 
just like the situation in this project as shown in figure \ref{fig:board-back}.
The display configuration in this case is:

%
\begin{lstlisting}[label=lis:dis-config,caption=DisplayGroup configuration]
DisplayGroup::DisplayManager disManager(PIN_COM_DATA, PIN_COM_CLOCK, PIN_OUTPUT_ENABLE);

disManager.addGroup("Home_score", 2, 0, &score.home, gDigits7, sizeof(gDigits7));
disManager.addGroup("Away_score", 2, 1, &score.away, gDigits7, sizeof(gDigits7));
disManager.addGroup("Period", 1, 2, &time.period, gDigits7, sizeof(gDigits7));
disManager.addGroup("Timer_minutes", 2, 3, &time.min, gDigits4, sizeof(gDigits4));
disManager.addGroup("Timer_seconds", 2, 4, &time.sec, gDigits4, sizeof(gDigits4));
\end{lstlisting}

where \code{score} and \code{time} are struct I used to keep information regarding the match score and the 
actual time. \code{gDigits7} and \code{gDigit4} are arrays of segments code, necessary for the library 
configuration, respectively for 7 inches and 4 inches displays. 

The second dependence library is AnalogButtonsGeneral, which is a slighlty modified version of AnalogButtons\footnote{\url{http://playground.arduino.cc/Code/AnalogButtons}},
and is used to control many digital inputs through few analog inputs from the Xbee analog to digital interface. 

This library has been modified to export the analog value to be read outside of the it's own code, into the application source. 
This is necessary to use, for example, a wireless sensor that reads the analog values and sends them on a serial connection. 
In general this is a required step every time the sensors or buttons are not physically connected to the Arduino analog input.

The configuration for this library is identical to the one of the original AnalogButtons library:
%
\begin{lstlisting}[label=lis:buttons-config,caption=AnalogButtonsGeneral configuration]
// Patch cable
const uint16_t bAVal[10] = { 50, 95, 110, 170, 200, 295, 310, 390 };


AnalogButtons homeButtons(HOME_ANALOG_INPUT, DEBOUNCING_COUNT_HOME, &handleHomeButtons);
Button b1 = Button(HOME_P1, bAVal[0], bAVal[1]);
Button b2 = Button(HOME_P2, bAVal[2], bAVal[3]);
Button b3 = Button(HOME_P3, bAVal[4], bAVal[5]);
Button b4 = Button(HOME_M1, bAVal[6], bAVal[7]);

AnalogButtons awayButtons(AWAY_ANALOG_INPUT, DEBOUNCING_COUNT, &handleAwayButtons);
Button b5 = Button(AWAY_P1, bAVal[0], bAVal[1]);
Button b6 = Button(AWAY_P2, bAVal[2], bAVal[3]);
Button b7 = Button(AWAY_P3, bAVal[4], bAVal[5]);
Button b8 = Button(AWAY_M1, bAVal[6], bAVal[7]);

AnalogButtons timerButtons(TIMER_ANALOG_INPUT, DEBOUNCING_COUNT, &handleTimerButtons);
Button b9 = Button(TIMER_START_STOP, bAVal[0], bAVal[1]);
Button b10 = Button(TIMER_RESET, bAVal[2], bAVal[3], HELD_DURATION);
Button b11 = Button(PERIOD_P1, bAVal[4], bAVal[5]);
Button b12 = Button(SETUP_MODE, bAVal[6], bAVal[7], HELD_DURATION);

void setup() {
  ...

  // Input Buttons
  homeButtons.addButton(b2);
  homeButtons.addButton(b1);
  homeButtons.addButton(b3);
  homeButtons.addButton(b4);
  
  awayButtons.addButton(b5);
  awayButtons.addButton(b6);
  awayButtons.addButton(b7);
  awayButtons.addButton(b8);

  timerButtons.addButton(b9);
  timerButtons.addButton(b10);
  timerButtons.addButton(b11);
  timerButtons.addButton(b12);
}

\end{lstlisting}

I used three analog inputs to control twelve digital inputs, called buttons in the program. 
For each analog input there is a callback function: \code{handleHomeButtons}, \code{handleAwayButtons}  
and \code{handleTimerButtons}. In these functions the control logic for each buttons is implemented.
Some of the buttons have an \code{HELD\_DURATION} options: these inputs must be held for some seconds to become active.

The third dependence library has been introduced along with the support for wireless communication, and is the SoftwareSerial\footnote{\url{http://arduino.cc/en/Reference/SoftwareSerial}} 
library, which is base on the NewSoftwareSerial library \footnote{\url{http://arduiniana.org/libraries/NewSoftSerial/}}. 
The communication between the receiving Xbee and Arduino is done via a serial link, supported by Arduino with 
the hardware serial port (digital IO 0 - 1), but those IO pins are needed also to communicate with a PC for example to debug the 
program. I didn't want to loose the \emph{only} debug chance that I had (the serial interface) so I used the software serial library 
which is able to emulate the RX and TX pins on any Arduino pin. The configuration is really easy:

%
\begin{lstlisting}[label=lis:softserial-config,caption=SoftwareSerial configuration]
// Xbee serial communication
#define SOFT_SERIAL_IN          6
#define SOFT_SERIAL_OUT         7

// Software serial input port (from Xbee)
SoftwareSerial xbeeSerial(SOFT_SERIAL_IN, SOFT_SERIAL_OUT);

void setup() {
  ...
  
  // Set the data rate for the SoftwareSerial port
  xbeeSerial.begin(19200);
}

\end{lstlisting}



\subsection{Main control program}

The main program is composed by the three library described in section \ref{subsec:dep} and by a main 
program that will be described in this section. The structure of the main program is shown in \ref{lis:main-structure} 
there are three callbacks to handle the analog input, one to handle the timer interrupt, and some 
functions to manage the EEPROM memory.

%
\begin{lstlisting}[label=lis:main-structure,caption=Main program structure]

void configureAnalogB();

// Handle home buttons pressed
void handleHomeButtons(int id, boolean held);

// Handle away buttons pressed and setup mode
void handleAwayButtons(int id, boolean held);

// Handle timer buttons pressed and setup mode
void handleTimerButtons(int id, boolean held);

// #########################################################
// ####### EEPROM wear leveling algorithm functions ########
// #########################################################

// EEPROM wear leveling algorithm prototypes
// Seek for the first writable cells in the EEPROM  i.e. the first cell counter
// with value smaller than EEPROM_MAX_WRITE
boolean initializeEEPROM();

// Write to the EEPROM cell with offset "offsetEE" and counter "counterEE" the
// actual value of score and time variables.
boolean writeEEPROM();

// Read from the EEPROM cell with offset "offsetEE" and counter "counterEE" the
// stored value of score and time variables.
void readEEPROM();

// Prints on the serial interface the contents of all the EEPROM cells
void printEEPROM();

// Buzzer managament: end of period or manual activation
void buzzer(boolean activation);

void setupDiplay();

// Handle serial communication with Xbee
void xbeeSerialCom(boolean debug);

// ========================================================
// |                        SETUP                         |
// ========================================================

void setup() {} 

// ========================================================
// |                        LOOP                          |
// ========================================================

void loop() {}
\end{lstlisting}

The \code{setup()} and \code{loop()} functions are necessary to the Arduino AVR compiler: 

\begin{itemize}
\item \code{setup()} provides the program initialization: it is used to configure the libraries
      and to check the state of the EEPROM memory (see \ref{subsubsec:wear-level});

\item \code{loop()} provides the main control loop: in this function the update of the displays is 
      executed and the actual state of the analog inputs is checked (see \ref{subsubsec:input-enable}).
\end{itemize}

The rest of the main program (the \code{main()} function) is automatically added by the Arduino library, 
so the final main program will be:

%
\begin{lstlisting}[label=lis:main-loop,caption=Main program from Arduino library]

#include <Arduino.h>

int main(void)
{
    init();

#if defined(USBCON)
    USBDevice.attach();
#endif
    
    setup();
    
    for (;;) {
        loop();
        if (serialEventRun) serialEventRun();
    }
        
    return 0;
}
\end{lstlisting}


\subsubsection{Input enable} \label{subsubsec:input-enable}

In the old scoreboard version, the digital inputs were mapped to the Arduino analog inputs through the 
board described in section \ref{subsec:contro-panel}. On this board the input are kept low with a pull 
down resistor. This means that when the input cable is disconnected the analog inputs were not connected 
to anything and they were not kept low! Thus the integer value read by Arduino was a random value between 
0 and 1023. This result was some weird behavior of the scoreboard like self-increasing score and timer 
disturbance because of the fake input.

The new version of the application itself uses an Xbee to read the actual analog values on the buttons lines,
and the Xbee is constantly connected to the control panel board, so this is not a problem any more! 

Anyway, the Arduino source code must constantly read analog values from the sensor for the input to work correctly, 
but this means that the Xbee radio should be always active. The battery drain in this case is unacceptable.
To preserve battery life, the Xbee is only waken up when necessary, and is kept awake for the minimum amount of time 
needed to transmit also the logical value 0 when the user releases all the buttons. In this way the code running on 
Arduino can reset it internal condition and be ready for the next button that will be pressed. 
 
There is still a problems with this type of digital-to-analog inputs: when the user pushes two or more buttons 
of different row at the same time some weird behavior can happen, but after some tests of the scoreboard for many 
games I can say this is not a real problem. Anyway this is not fixable with a software approach, instead a careful
choice of the resistors values is necessary to avoid such problems. 



\subsubsection{Countdown timer} \label{subsubsec:timer}


A basketball game, just like many other sports, requires a countdown timer to keep trace of the effective 
time in the game. This timer could be easily made using the \code{delay()} or \code{millis()} functions 
in the Arduino APIs, but since the precision matters I decided to use an hardware interrupt with precise 
calculation behind. 
The Arduino platform can generate some hardware interrupt using counters and the configuration is easy if 
you have some introduction to interrupt logic and setup in the microcontrollers field. If not you can read 
this good introduction \footnote{\url{http://www.engblaze.com/microcontroller-tutorial-avr-and-arduino-timer-interrupts/}},
which end up with exactly with the configuration I used. The Atmel AVR CPU datasheet is the resource where 
you can find some more detailed information on the internals configurations (for the Arduino Uno the 
CPU is the ATmega328p \footnote{\url{http://www.atmel.com/devices/ATMEGA328P.aspx}}).   

I will describe here only the configuration I used, since all the other information can be easily found at the 
resource I pointed to or elsewhere in the Internet.
I used the Clear Timer on Compare Match, or \emph{CTC}, interrupt on timer 1, with system clock as counter clock.
The timer compares its count to a value that was previously stored in a register. When the count matches that 
value, the timer can either set a flag or trigger an interrupt. The interrupt will be served by an \emph{ISR} 
(Interrupt Service Routine), in which the user can put the needed code.
Using a prescaler of 1024 the compare match value $T_c$ to fire the interrupt every second is 15624, considering 
the CPU frequency (16MHz). This value is obtained as

\[
 T_c = \left(  \frac{T_t}{T_r} \right) - 1 
\]

where $T_t$ is the timer target time, 1 s in this application, and $T_r$ is the time resolution given the CPU 
clock frequency and the prescaler, obtained as

\[
 T_r = \frac{prescaler}{CPU_f} = 6.4\e{-5} \, s
\]
 
Once the timer 1 reaches this value the ISR will be executed: 

%
\begin{lstlisting}[label=lis:timer-ISR,caption=Interrupt Service Routine]
ISR(TIMER1_COMPA_vect) {
  sec--;
  updateDisplay = true;
  saveEEprom = true;
}
\end{lstlisting}

The function manages the total seconds counter, and sets some flags to write the new time on the 
internal EEPROM and to refresh the displays. Thus, when the time is updated the new time is shown on the 
displays as soon as possible. 
Some care must be taken to avoid problems at runtime due to the compiler optimizations: the variables shared 
between the ISR and the rest of the code have to be declared \code{volatile}, and they have to be copied to 
a local variable in a interrupt free context, saving and restoring the status register (\emph{SREG}): 

%
\begin{lstlisting}[label=lis:main-timer,caption=Read shared variables in the main program ]
// Interrupt free context to update shared volatile variables
sreg = SREG;
cli();
updateDisplayLocal = updateDisplay;
saveEEpromLocal = saveEEprom;
updateDisplay = false;
saveEEprom = false;
secLocal = sec;
sei();
SREG = sreg;
\end{lstlisting}

The same special code should be used when setting and resetting the timer 1 counter value or the configuration 
registry, as shown in listings \ref{lis:setup-timer} and \ref{lis:timer-use}.

%
\begin{lstlisting}[label=lis:setup-timer,caption=Setup of the timer interrupt]
void setup() {
  ...
  // Setup of timer1 CTC interrupt
  // Initialize Timer1
  cli();          // disable global interrupts
  TCCR1A = 0;     // set entire TCCR1A register to 0
  TCCR1B = 0;     // same for TCCR1B

  // Set compare match register to desired timer count
  OCR1A = 15624;
  // Turn on CTC mode
  // TCCR1B |= (1 << WGM12);
  // Set CS10 and CS12 bits for 1024 prescaler
  // TCCR1B |= (1 << CS10);
  // TCCR1B |= (1 << CS12);
  // So its TCCR1B = 13 the make the timer start

  // Enable timer compare interrupt:
  TIMSK1 |= (1 << OCIE1A);
  sei();          // Enable global interrupts:
}
\end{lstlisting}


%
\begin{lstlisting}[label=lis:timer-use,caption=Use of the timer]
case TIMER_START_STOP:
      if (timerRunning) {
        // Stop timer, save global interrupt flag and restore after
        sreg = SREG;
        cli();
        TCCR1B = 0;
        SREG = sreg;

        timerRunning = false;
        updateDisplay = true;
      } else {
        // Start/restart timer
        if (time.min == 0 && time.sec == 0) {
          return;
        }
        sreg = SREG;
        cli();
        TCCR1B = 13;
        SREG = sreg;

        timerRunning = true;
        updateDisplay = true;
      }
      break;

    case TIMER_RESET:
      if (!timerRunning && held) {
        sreg = SREG;
        cli();
        TCNT1 = 0;
        SREG = sreg;

        time.min = TIMER_INIT_MIN;
        time.sec = TIMER_INIT_SEC;
        sec = TIMER_INIT_MIN * 60 + TIMER_INIT_SEC;
      }
      updateDisplay = true;
      break;
\end{lstlisting}


The accuracy in time of this interrupt depends on the stability of the crystal oscillator integrated in the CPU, 
which is +/- 50 ppm, so it is +/- 2 minutes clock's error during one month. If the crystal is working at constant 
room temperature stability should be even better.  



\subsubsection{EEPROM wear leveling} \label{subsubsec:wear-level}

The Arduino internal EEPROM memory has uniques electrically erasable cells, up to 1024 bytes. Each of these 
cell can be erases a limited number of time (erase cycle) before becoming unreliable. For the Arduino UNO r3
CPU the life is about 100000 erase cycle for \emph{each} cell. Since the erase cycle is executed 
also upon a write cycle the cell write cycles are limited too. A wear leveling algorithm attempts to work around 
these limitations by arranging data in a such a way that re-writes are distributed evenly across the medium. 
In this way no single erase cell prematurely fails due to a high concentration of write cycles. 

In this application the EEPROM memory is used to store the march data (score and time) and to restore them in 
case of power loss. I wanted to save every change in the data, so the time changes every second and this result 
in a write cycle for some cells in the memory. Also when the score changes it is written to the memory. 
Given that every basketball game is composed by at least 4 period, and each period lasts 10 minutes (effective 
time), the average number of writing command no the EEPROM per game is:

\[
W_m \simeq 60 \; seconds * 10 \; minutes * 4 \; periods + 100 \; score \, change \simeq 2500 writings
\]

I considered 100 additional writing to account for the score changes, which themselves generate an independent 
write cycle on the EEPROM.  

Each write cycle involves the whole amount of data shown in listing \ref{lis:persistent-data}:

%
\begin{lstlisting}[label=lis:persistent-data,caption=Persistent data type]
// ####################### Data types #######################
struct Score {
  uint16_t home;        // 2 bytes
  uint16_t away;        // 2 bytes
};

struct Time {
  uint16_t min;         // 2 bytes
  uint16_t sec;         // 2 bytes
  uint16_t period;      // 2 bytes
};

// Pesistend data type to be written on the EEPROM
struct persistentData {
  uint32_t counter;     // 4 bytes
  Score score;          // 4 bytes
  Time time;            // 6 bytes
};
\end{lstlisting}

The data type \code{persistentData} size is 14 bytes: so 14 cells will be written on each write command. The 
\code{counter} variable is used to keep trace of the how many writes have been executed on the cell group. If 
I used only one group of 14 cells the total memory life would be:

\[
L = \frac{100000}{W_m} = 40 \; games
\] 

This means that after only 40 games the first 14 cells of the EEPROM would have been written 100000 times, and thus 
the cells would be not reliable any more. But the EEPROM is made of 1024 cells that can be used! 

In my simple algorithm I decided to use $G = \lfloor\tfrac{1024}{14}\rfloor = 73$ groups, in this way I can use 
the whole memory, starting from the first group and shifting the write cycle on to the next group when the previous 
one has become unreliable, after 100000 write cycles. 
This procedure allows the application to last much longer, in particular:

\[
L = 73 \; * \; \frac{100000}{W_m} = 2920 \; games
\]

This life is more than enough for my need so, although the algorithm can be easily improved, I used this version of 
the wear leveling algorithm, implemented by some functions in the main program.

Those function use the \code{avr/eeprom.h} library found in the Arduino include directory to read and write the EEPROM 
cells. are:

\begin{description}
\item[\code{initializeEEPROM()}]:

Used to initialize the algorithm to write the EEPROM starting from the first not 
out of order cell, i.e. its life is not over. This function scans the whole memory and find the first usable cell,
than the rest of the algorithm will write starting from this location. If the memory is full, i.e. there are no 
remaining cells, the application will not save anything and the related functions will be not used.
This functions read also the last saved values if present, which can be restored at any time using the control 
panel in setup mode. The values are stored in RAM so that the application can still save the data when needed 
without overwrite the restore data in the EEPROM.
\end{description}

%
\begin{lstlisting}[label=lis:initializeEEPROM,caption=initializeEEPROM() function]
boolean initializeEEPROM() {
  persistentData data;

  uint16_t size = sizeof(data);

  uint16_t readCounter = (uint16_t) EEPROM_SIZE / size;

  for (uint16_t i = 0; i < readCounter; i++) {
    eeprom_read_block((void*) &data, (void*) (size * i), sizeof(data));

    if (data.counter < EEPROM_MAX_WRITE) {
      if (data.counter == 0 && i > 0) {
        // Read from previous cell, just reached end of life
        i--;
        eeprom_read_block((void*) &data, (void*) (size * i), sizeof(data));
      }
      counterEE = data.counter;
      offsetEE = size * i;
      dataEE = data;
      return true;
    }
  }

  // EEPROM full (end of life), read last saved data
  dataEE = data;
  return false;
}
\end{lstlisting}


\begin{description}
\item[\code{writeEEPROM()}]: 

Used to write the actual data to the EEPROM when requested by the application. The function writes the data and 
increment the actual write counter in the cell group. If the is no cells available the function simply returns.
\end{description}

%
\begin{lstlisting}[label=lis:writeEEPROM,caption=writeEEPROM() function]
boolean writeEEPROM() {
  persistentData data;
  uint16_t size = sizeof(data);

  counterEE++;

  if (counterEE > EEPROM_MAX_WRITE) {
    offsetEE += size;
    counterEE = 1;
  }

  if (offsetEE >= EEPROM_SIZE) {
    return false;
  }

  data.counter = counterEE;
  data.score = score;
  data.time = time;

  eeprom_write_block((void*) &data, (void*) offsetEE, sizeof(data));

  return true;
}
\end{lstlisting}

The are two other service functions: \code{readEEPROM()} and \code{printEEPROM()}: the former reads the data in the 
EEPROM at a specified offset, and the latter prints the EEPROM content to the serial interface, to show the actual 
state of the memory, for debug purpose.


\subsection{Wireless Extension}\label{subsec:sw-wireless}

This wireless version of the project requires some custom functions in both the ATtiny MCU on the transmitter and 
on the Arduino at the receiving site.

\subsubsection{ATtiny code}\label{subsubsec:sw-attiny}

The ATtiny main code is shown in listing \ref{lis-attiny}: it simply setup a pin in output mode to put the Xbee 
to sleep, setup the watchdog interrupt, and setup some internal registers value to reduce power consumption.
The \code{loop} function scans for some button pressed with a minimum analog threshold, and in case at least 
one button is pressed, the Xbee is waken up with a low output on the \code{WAKE\_OUTPUT} pin.


%
\begin{lstlisting}[label=lis-attiny,caption=ATtiny main code]
void system_sleep() {
  cbi(ADCSRA, ADEN);                     // Switch Analog to Digitalconverter OFF
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);   // Sleep mode is set here
  sleep_enable();
  sleep_mode();                          // System actually sleeps here
  sleep_disable();                       // System continues execution here when
                                         // watchdog timed out
  sbi(ADCSRA, ADEN);                     // Switch Analog to Digitalconverter ON
}

// Watchdog Interrupt Service Routine
ISR(WDT_vect) {
  wdCount++;
}

// ========================================================
// |                        SETUP                         |
// ========================================================

void setup() {
  pinMode(WAKE_OUTPUT, OUTPUT);
  digitalWrite(WAKE_OUTPUT, HIGH);

  // Setup watchdog timeout
  setup_watchdog(0);

  // Set the internal registers to reduce power consumes
  PRR &= ~(1<<PRTIM1);                   // Shut down the timer1
  ACSR = (1<<ACD);                       // Shut down the analog comparator
  MCUCR |= (1<<BODS);                    // BOD disabled

} // End of setup

// ========================================================
// |                        LOOP                          |
// ========================================================

void loop() {

  system_sleep();                        // Send the unit to sleep

  boolean pressedHome = (analogRead(HOME_ANALOG_INPUT) > MIN_ANA_TH);
  boolean pressedAway = (analogRead(AWAY_ANALOG_INPUT) > MIN_ANA_TH);
  boolean pressedTimer = (analogRead(TIMER_ANALOG_INPUT) > MIN_ANA_TH);

  if (pressedHome || pressedAway || pressedTimer) {
    digitalWrite(WAKE_OUTPUT, LOW);
    wdCount = 0;
  } else if (wdCount >= WD_CMP_MATCH) {
    digitalWrite(WAKE_OUTPUT, HIGH);
    wdCount = 0;
  }

} // End of loop

\end{lstlisting}

The \code{wdCount} variable is incremented by the watchdog interrupt; in case no buttons is pressed, after 
\code{WD\_CMP\_MATCH} interrupt fired the MCU will write high on the output, letting the Xbee sleep again.
The watchdog timeout and the \code{WD\_CMP\_MATCH} count are chosen in such a way that the Xbee will stay 
awake for the necessary amount of time to sample the analog input, build the package and send it. 
The expression is:

\[
wdCount \; * \; wdInterval \geq xBeeTX \; * \; xBeeIR
\]

Where $xBeeTX$ and $xBeeIR$ are the xBee configuration parameters TX (sample before transmission) and IR (sample 
rate in ms). In this application the values are: $5 \; * \; 16ms \geq 2 \; * \; 40ms$.
Thus, after the buttons have been released, the Xbee will be awake for at least other 80ms, and will send another 
package with the sampled values equal to 0. In this way the Arduino code can recognise that no button is pressed 
any more.


\subsubsection{Arduino code}\label{subsubsec:sw-arduino}

The Arduino main code has been modified to add a function, \code{xbeeSerialCom()}, used to parse serial data coming 
from the Xbee. The listing \ref{lis-arduino} shows the method without debugging flags: 

%
\begin{lstlisting}[label=lis-arduino,caption=Arduino main code: xbeeSerialCom function]
void xbeeSerialCom() {
  int xbeeDel = 0x7E;
  int car = 0;
  int frameType = 0;
  int sourceAdr = 0;
  int sampleN = 0;
  int analogReadings[N_ANALOG_INPUT];

  if (xbeeSerial.available() >= 18) {

    // Seek for the frame delimiter "xbeeDel", -1 indicates empty serial buffer
    while ((car = xbeeSerial.read()) != xbeeDel) {
      if (car == -1) {
        return;
      }
    }

    // Reading API frame type 83 header
    for (byte i = 2; i <= 8; ++i) {
      car = xbeeSerial.read();

      if (i== 4) {
        frameType = car;
        if (frameType == 97) {
          return;
        }
      } else if (i == 6) {
        sourceAdr = car;
      }
    }

    // Reading header of IO data frame
    // Reading number of samples
    sampleN = xbeeSerial.read();

    // Reading IO channel enabled mask: not used
    car = xbeeSerial.read();
  
    // Reading 0 byte
    car = xbeeSerial.read();

    // Reading paylod: only ADC values
    int msb[N_ANALOG_INPUT], lsb[N_ANALOG_INPUT];
    for (byte j = 0; j < sampleN; ++j) {

      for (byte i = 0; i < N_ANALOG_INPUT; ++i) {
        msb[i] = xbeeSerial.read();
        lsb[i] = xbeeSerial.read();
        analogReadings[i] = lsb[i] + (msb[i] * 256);
      }
	  
      // Analog input received, check for buttons pressed
      // only if the Xbee source address is recognized
      if (sourceAdr == XBEE_SOURCE_ADR) {
        homeButtons.checkValue(analogReadings[0]);
        awayButtons.checkValue(analogReadings[1]);
        timerButtons.checkValue(analogReadings[2]);
      }
    }
    // Reading checksum - at the end of the frame
    car = xbeeSerial.read();
  }
}
\end{lstlisting}

Rows 12-16 read every character until the start frame delimiter, \code{0x7E}.
Rows 19-30 read every character in the API frame header. The IO data parsing begins at line 32: number of samples,
digital IO mask, and analog values in the form of 2 byte for each analog input.
On line 54 a security check is made, to verify the source Xbee 16bit address.
On lines 55-57 the \code{AnalogButtonsGeneral::checkvalue()} method is called, once for 
each analog line, to check the current analog value and if a buttons is pressed.


\subsection{Volleyball mode}

In a recent release sthe volleyball mode has been implemented. This was done upon request from the volleyball 
coach, so I tried to adapt the software without touching the hardware (the scoreboard is already mounted on the wall 
by now). The new mode simply changes the meaning of some displays in a way that is better suited for a volleyball 
match.
%
\begin{figure}[htb]
\centering\includegraphics[scale=0.32]{img/Scoreboard_volley}

\caption{ScoreBoard in volleyball mode \label{fig:volleyball-mode}}

\end{figure}

Figure \ref{fig:volleyball-mode} shows the new configuration: the two upper display groups show the score for each team.
The central one shows the current set in the match, and the two at the bottom show the sets won by each team.
In listing \ref{lis:volleyMode} is shown the code responsable for the configuration switch: using the DisplayGroup 
library API the main program cleans the displays configuration when the volleyball mode is activated (row 5) and 
inserts the new configuration (rows 7-16). The same procedure is carried out when the same button is pressed again,
switching back the configuration to basketball mode.

%
\begin{lstlisting}[label=lis:volleyMode,caption=Volleyball mode activation and deactivation]
volleyMode = !volleyMode;

if (volleyMode) {
  // Volleyball mode
  disManager.clearGroups();

  disManager.addGroup(0, 2, &vScore.home, gDigits7, sizeof(gDigits7));
  disManager.addGroup(1, 2, &vScore.away, gDigits7, sizeof(gDigits7));
  disManager.addGroup(2, 1, &vSets.actSet, gDigits7, sizeof(gDigits7));
  disManager.addGroup(3, 1, NULL);
  disManager.addGroup(4, 1, &vSets.homeSet, gDigits4, sizeof(gDigits4));
  disManager.addGroup(5, 1, &vSets.awaySet, gDigits4, sizeof(gDigits4));
  disManager.addGroup(6, 1, NULL);

  disManager.enableGroup(3, false);
  disManager.enableGroup(6, false);

} else {
  // Basketball mode
  disManager.clearGroups();
  
  disManager.addGroup(0, 2, &bScore.home, gDigits7, sizeof(gDigits7));
  disManager.addGroup(1, 2, &bScore.away, gDigits7, sizeof(gDigits7));
  disManager.addGroup(2, 1, &time.period, gDigits7, sizeof(gDigits7));
  disManager.addGroup(3, 2, &time.min, gDigits4, sizeof(gDigits4));
  disManager.addGroup(4, 2, &time.sec, gDigits4, sizeof(gDigits4));
}
\end{lstlisting}

The input mode must be setupMode and one button will allow the user to switch between basketball mode and 
volleyball mode. Two groups are disabled (rows 15-16) because they are not used to show the number of 
sets won by the two teams (a digit is enough for each team!).
The switch can be carried out on the fly, at runtime, and all the information regarding on mode or the other 
are kept back in the respective variables; thus when the user switches back to one mode he will find the displays 
in the same state they were when he left that mode. This works only if there hasn't been any power cycle in between, 
because the backup on the EEPROM memory works only for basketball mode. 

\end{document}



